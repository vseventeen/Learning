# 排序算法
----------
## 1. 快速排序
原理：在待排序列中任一选择一个元素作为基准（piovt），拿剩余元素与其比较，比较完毕后分为两组：大于基准的元素和小于基准的元素。如此递归。（一般选择第一位或最后一位作为基准）

算法描述：  
1. 选择第一位为基准元素  
2. 从 j 开始，与基准比较。若 j 位置大于基准，则 j 减一，直到 j 位置元素小于基准，二者交换且 i 加一。  
3. 发生交换，此时比较 i 位置元素与基准大小，若小于等于基准则 i 加一，否则交换且 j 减一。 
选择第一位3作为基准，i 指向第一位， j 指向最后一位（i = 0, j = 9）  
4. 循环步骤(2)，(3)直到 i = j.  
  
**演示：**  
有无序序列 arr [3, 5, 0, 7, 6, 1, 10, 7, 2, 8]，使用快速排序对其进行排序    
j = 9 : [***3***, 5, 0, 7, 6, 1, 10, 7, 2, **8**] 8 > 3, j--   
j = 8 : [***3***, 5, 0, 7, 6, 1, 10, 7, **2**, 8] 2 < 3, swap, i++  
i = 1 : [2, **5**, 0, 7, 6, 1, 10, 7, ***3***, 8] 5 > 3, swap, j--  
j = 7 : [2, ***3***, 0, 7, 6, 1, 10, **7**, 5, 8] 7 > 3, j--  
j = 6 : [2, ***3***, 0, 7, 6, 1, **10**, 7, 5, 8] 10 > 3, j--  
j = 5 : [2, ***3***, 0, 7, 6, **1**, 10, 7, 5, 8] 1 < 3, swap, i++   
i = 2 : [2, 1, **0**, 7, 6, ***3***, 10, 7, 5, 8] 0 < 3, i++  
i = 3 : [2, 1, 0, **7**, 6, ***3***, 10, 7, 5, 8] 7 > 3, swap, j--  
j = 4 : [2, 1, 0, ***3***, **6**, 7, 10, 7, 5, 8] 6 > 3, j--  
j = 3 = i  
至此，基准的位置已确定，接下来就是对基准两侧的元素分别递归进行上述步骤即可。

## 2.归并排序
原理：使用分治策略，将序列一次对半使任务减半。主要有两个步骤：1. 分解序列； 2. 合并序列。
**分解序列：**将原序列对半分解，直到只有一个元素。 （共有logn层）  
**合并序列：**对相邻两个序列进行合并，依次取出较小的元素放进临时数组中。此时的序列为有序序列。  （每一层比较n次）

**演示：**  
有无序序列 arr [3, 5, 0, 7, 6, 1, 10, 7, 2]，使用归并排序对其进行排序.
![](https://raw.githubusercontent.com/vseventeen/Learning/c5d18fd60ba9dbf4a780c720efac0fd57f971905/src/com/sortingalgorithm/MergeSort.JPG)
 


